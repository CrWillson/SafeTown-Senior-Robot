<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SafeTown Senior Robot: xQueueSendFromISR</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SafeTown Senior Robot
   </div>
   <div id="projectbrief">Arduino workspace for SafeTown Senior Robot development.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/df6/group__x_queue_send_from_i_s_r.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">xQueueSendFromISR</div></div>
</div><!--header-->
<div class="contents">
<p>queue. h </p><div class="fragment"><div class="line">BaseType_t xQueueSendToFrontFromISR(</div>
<div class="line">                                      QueueHandle_t xQueue,</div>
<div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">void</span> *pvItemToQueue,</div>
<div class="line">                                      BaseType_t *pxHigherPriorityTaskWoken</div>
<div class="line">                                   );</div>
</div><!-- fragment --><p>This is a macro that calls xQueueGenericSendFromISR().</p>
<p>Post an item to the front of a queue. It is safe to use this macro from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xQueue</td><td>The handle to the queue on which the item is to be posted.</td></tr>
    <tr><td class="paramname">pvItemToQueue</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</td></tr>
    <tr><td class="paramname">pxHigherPriorityTaskWoken</td><td>xQueueSendToFrontFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendToFrontFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd></dl>
<p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> vBufferISR( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">char</span> cIn;</div>
<div class="line">BaseType_t xHigherPriorityTaskWoken;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// We have not woken a task at the start of the ISR.</span></div>
<div class="line"> xHigherPriorityTaskWoken = pdFALSE;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop until the buffer is empty.</span></div>
<div class="line"> <span class="keywordflow">do</span></div>
<div class="line"> {</div>
<div class="line">     <span class="comment">// Obtain a byte from the buffer.</span></div>
<div class="line">     cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Post the byte.</span></div>
<div class="line">     xQueueSendToFrontFromISR( xRxQueue, &amp;cIn, &amp;xHigherPriorityTaskWoken );</div>
<div class="line"> </div>
<div class="line"> } <span class="keywordflow">while</span>( portINPUT_BYTE( BUFFER_COUNT ) );</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Now the buffer is empty we can switch context if necessary.</span></div>
<div class="line"> <span class="keywordflow">if</span>( xHigherPriorityTaskWoken )</div>
<div class="line"> {</div>
<div class="line">     taskYIELD ();</div>
<div class="line"> }</div>
<div class="line">}</div>
</div><!-- fragment --><p>queue. h </p><div class="fragment"><div class="line">BaseType_t xQueueSendToBackFromISR(</div>
<div class="line">                                      QueueHandle_t xQueue,</div>
<div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">void</span> *pvItemToQueue,</div>
<div class="line">                                      BaseType_t *pxHigherPriorityTaskWoken</div>
<div class="line">                                   );</div>
</div><!-- fragment --><p>This is a macro that calls xQueueGenericSendFromISR().</p>
<p>Post an item to the back of a queue. It is safe to use this macro from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xQueue</td><td>The handle to the queue on which the item is to be posted.</td></tr>
    <tr><td class="paramname">pvItemToQueue</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</td></tr>
    <tr><td class="paramname">pxHigherPriorityTaskWoken</td><td>xQueueSendToBackFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendToBackFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd></dl>
<p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> vBufferISR( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">char</span> cIn;</div>
<div class="line">BaseType_t xHigherPriorityTaskWoken;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// We have not woken a task at the start of the ISR.</span></div>
<div class="line"> xHigherPriorityTaskWoken = pdFALSE;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop until the buffer is empty.</span></div>
<div class="line"> <span class="keywordflow">do</span></div>
<div class="line"> {</div>
<div class="line">     <span class="comment">// Obtain a byte from the buffer.</span></div>
<div class="line">     cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Post the byte.</span></div>
<div class="line">     xQueueSendToBackFromISR( xRxQueue, &amp;cIn, &amp;xHigherPriorityTaskWoken );</div>
<div class="line"> </div>
<div class="line"> } <span class="keywordflow">while</span>( portINPUT_BYTE( BUFFER_COUNT ) );</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Now the buffer is empty we can switch context if necessary.</span></div>
<div class="line"> <span class="keywordflow">if</span>( xHigherPriorityTaskWoken )</div>
<div class="line"> {</div>
<div class="line">     taskYIELD ();</div>
<div class="line"> }</div>
<div class="line">}</div>
</div><!-- fragment --><p>queue. h </p><div class="fragment"><div class="line">BaseType_t xQueueSendFromISR(</div>
<div class="line">                                  QueueHandle_t xQueue,</div>
<div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">void</span> *pvItemToQueue,</div>
<div class="line">                                  BaseType_t *pxHigherPriorityTaskWoken</div>
<div class="line">                             );</div>
</div><!-- fragment --><p>This is a macro that calls xQueueGenericSendFromISR(). It is included for backward compatibility with versions of FreeRTOS.org that did not include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR() macros.</p>
<p>Post an item to the back of a queue. It is safe to use this function from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xQueue</td><td>The handle to the queue on which the item is to be posted.</td></tr>
    <tr><td class="paramname">pvItemToQueue</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</td></tr>
    <tr><td class="paramname">pxHigherPriorityTaskWoken</td><td>xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd></dl>
<p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> vBufferISR( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">char</span> cIn;</div>
<div class="line">BaseType_t xHigherPriorityTaskWoken;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// We have not woken a task at the start of the ISR.</span></div>
<div class="line"> xHigherPriorityTaskWoken = pdFALSE;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop until the buffer is empty.</span></div>
<div class="line"> <span class="keywordflow">do</span></div>
<div class="line"> {</div>
<div class="line">     <span class="comment">// Obtain a byte from the buffer.</span></div>
<div class="line">     cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Post the byte.</span></div>
<div class="line">     xQueueSendFromISR( xRxQueue, &amp;cIn, &amp;xHigherPriorityTaskWoken );</div>
<div class="line"> </div>
<div class="line"> } <span class="keywordflow">while</span>( portINPUT_BYTE( BUFFER_COUNT ) );</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Now the buffer is empty we can switch context if necessary.</span></div>
<div class="line"> <span class="keywordflow">if</span>( xHigherPriorityTaskWoken )</div>
<div class="line"> {</div>
<div class="line">      <span class="comment">// As xHigherPriorityTaskWoken is now set to pdTRUE then a context</span></div>
<div class="line">      <span class="comment">// switch should be requested. The macro used is port specific and</span></div>
<div class="line">      <span class="comment">// will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() -</span></div>
<div class="line">      <span class="comment">// refer to the documentation page for the port being used.</span></div>
<div class="line">      portYIELD_FROM_ISR( xHigherPriorityTaskWoken );</div>
<div class="line"> }</div>
<div class="line">}</div>
</div><!-- fragment --><p>queue. h </p><div class="fragment"><div class="line">BaseType_t xQueueGenericSendFromISR(</div>
<div class="line">                                        QueueHandle_t    xQueue,</div>
<div class="line">                                        <span class="keyword">const</span>    <span class="keywordtype">void</span>    *pvItemToQueue,</div>
<div class="line">                                        BaseType_t  *pxHigherPriorityTaskWoken,</div>
<div class="line">                                        BaseType_t  xCopyPosition</div>
<div class="line">                                    );</div>
</div><!-- fragment --><p>It is preferred that the macros xQueueSendFromISR(), xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place of calling this function directly. xQueueGiveFromISR() is an equivalent for use by semaphores that don't actually copy any data.</p>
<p>Post an item on a queue. It is safe to use this function from within an interrupt service routine.</p>
<p>Items are queued by copy not reference so it is preferable to only queue small items, especially when called from an ISR. In most cases it would be preferable to store a pointer to the item being queued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xQueue</td><td>The handle to the queue on which the item is to be posted.</td></tr>
    <tr><td class="paramname">pvItemToQueue</td><td>A pointer to the item that is to be placed on the queue. The size of the items the queue will hold was defined when the queue was created, so this many bytes will be copied from pvItemToQueue into the queue storage area.</td></tr>
    <tr><td class="paramname">pxHigherPriorityTaskWoken</td><td>xQueueGenericSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueGenericSendFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</td></tr>
    <tr><td class="paramname">xCopyPosition</td><td>Can take the value queueSEND_TO_BACK to place the item at the back of the queue, or queueSEND_TO_FRONT to place the item at the front of the queue (for high priority messages).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pdTRUE if the data was successfully sent to the queue, otherwise errQUEUE_FULL.</dd></dl>
<p>Example usage for buffered IO (where the ISR can obtain more than one value per call): </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> vBufferISR( <span class="keywordtype">void</span> )</div>
<div class="line">{</div>
<div class="line"><span class="keywordtype">char</span> cIn;</div>
<div class="line">BaseType_t xHigherPriorityTaskWokenByPost;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// We have not woken a task at the start of the ISR.</span></div>
<div class="line"> xHigherPriorityTaskWokenByPost = pdFALSE;</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Loop until the buffer is empty.</span></div>
<div class="line"> <span class="keywordflow">do</span></div>
<div class="line"> {</div>
<div class="line">     <span class="comment">// Obtain a byte from the buffer.</span></div>
<div class="line">     cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );</div>
<div class="line"> </div>
<div class="line">     <span class="comment">// Post each byte.</span></div>
<div class="line">     xQueueGenericSendFromISR( xRxQueue, &amp;cIn, &amp;xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );</div>
<div class="line"> </div>
<div class="line"> } <span class="keywordflow">while</span>( portINPUT_BYTE( BUFFER_COUNT ) );</div>
<div class="line"> </div>
<div class="line"> <span class="comment">// Now the buffer is empty we can switch context if necessary.</span></div>
<div class="line"> <span class="keywordflow">if</span>( xHigherPriorityTaskWokenByPost )</div>
<div class="line"> {</div>
<div class="line">      <span class="comment">// As xHigherPriorityTaskWokenByPost is now set to pdTRUE then a context</span></div>
<div class="line">      <span class="comment">// switch should be requested. The macro used is port specific and</span></div>
<div class="line">      <span class="comment">// will be either portYIELD_FROM_ISR() or portEND_SWITCHING_ISR() -</span></div>
<div class="line">      <span class="comment">// refer to the documentation page for the port being used.</span></div>
<div class="line">      portYIELD_FROM_ISR( xHigherPriorityTaskWokenByPost );</div>
<div class="line"> }</div>
<div class="line">}</div>
</div><!-- fragment --> </div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Apr 8 2025 17:22:09 for SafeTown Senior Robot by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
